#!/bin/bash
# JMRI Installation Script for dcc-io-daemon
# Downloads and installs JMRI from GitHub releases

set -e
# Don't exit on errors in pipes or command substitutions
set +o pipefail

JMRI_BASE_DIR="/opt/jmri"
JMRI_CURRENT_LINK="${JMRI_BASE_DIR}/current"
GITHUB_API="https://api.github.com/repos/JMRI/JMRI/releases"
GITHUB_RELEASES="https://github.com/JMRI/JMRI/releases"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

error() {
    echo -e "${RED}ERROR:${NC} $1" >&2
    exit 1
}

info() {
    echo -e "${GREEN}INFO:${NC} $1"
}

warn() {
    echo -e "${YELLOW}WARN:${NC} $1"
}

# Parse command line arguments
INSTALL_LATEST=false
if [ "$1" = "--latest" ] || [ "$1" = "-l" ]; then
    INSTALL_LATEST=true
fi

# Check if running as root
if [ "$EUID" -ne 0 ]; then
    error "This script must be run as root (use sudo)"
fi

# Check for required commands
for cmd in curl jq tar; do
    if ! command -v $cmd &> /dev/null; then
        error "$cmd is required but not installed. Please install it first."
    fi
done

# Create JMRI base directory if it doesn't exist
mkdir -p "$JMRI_BASE_DIR"
chmod 755 "$JMRI_BASE_DIR"

info "Fetching JMRI releases from GitHub..."

# Fetch releases from GitHub API with better error handling
# Add User-Agent header as GitHub API requires it
RELEASES_JSON=$(curl -s -f -H "User-Agent: dcc-io-daemon-jmri-install" "$GITHUB_API" 2>&1)
CURL_EXIT=$?

if [ $CURL_EXIT -ne 0 ]; then
    # Check if it's a rate limit error
    if echo "$RELEASES_JSON" | grep -qi "rate limit"; then
        error "GitHub API rate limit exceeded. Please try again later."
    fi
    error "Failed to fetch releases from GitHub API: $RELEASES_JSON"
fi

# Check if response is empty
if [ -z "$RELEASES_JSON" ]; then
    error "Empty response from GitHub API. Check your internet connection."
fi

# Check if we got valid JSON
if ! echo "$RELEASES_JSON" | jq empty 2>/dev/null; then
    # Try to see what we got
    echo "DEBUG: First 200 chars of response:" >&2
    echo "$RELEASES_JSON" | head -c 200 >&2
    echo "" >&2
    error "Invalid JSON response from GitHub API. Check your internet connection or GitHub API status."
fi

# Check if we got an error message from GitHub API
if echo "$RELEASES_JSON" | jq -e '.message' >/dev/null 2>&1; then
    ERROR_MSG=$(echo "$RELEASES_JSON" | jq -r '.message')
    error "GitHub API error: $ERROR_MSG"
fi

# Check if response is an array
if ! echo "$RELEASES_JSON" | jq -e 'type == "array"' >/dev/null 2>&1; then
    error "GitHub API did not return an array. Response type: $(echo "$RELEASES_JSON" | jq -r 'type')"
fi

# Parse releases into production and test arrays
declare -a PRODUCTION_RELEASES
declare -a TEST_RELEASES
declare -a ALL_RELEASES

# Process each release (limit to latest 10)
RELEASE_COUNT=$(echo "$RELEASES_JSON" | jq 'length')
MAX_RELEASES=10
if [ "$RELEASE_COUNT" -gt "$MAX_RELEASES" ]; then
    RELEASE_COUNT=$MAX_RELEASES
    info "Showing latest $MAX_RELEASES releases (out of $(echo "$RELEASES_JSON" | jq 'length') total)"
fi

info "Processing $RELEASE_COUNT releases..."

for ((i=0; i<RELEASE_COUNT; i++)); do
    TAG_NAME=$(echo "$RELEASES_JSON" | jq -r ".[$i].tag_name")
    NAME=$(echo "$RELEASES_JSON" | jq -r ".[$i].name")
    PRERELEASE=$(echo "$RELEASES_JSON" | jq -r ".[$i].prerelease")
    
    # Find the .tgz asset (match files starting with JMRI and ending with .tgz)
    # Use a simpler approach - check if name starts with JMRI and ends with .tgz
    TGZ_URL=$(echo "$RELEASES_JSON" | jq -r ".[$i].assets[] | select((.name | startswith(\"JMRI\")) and (.name | endswith(\".tgz\"))) | .browser_download_url" 2>/dev/null | head -1 || echo "")
    
    # Debug: show what we found (only for first few releases)
    if [ $i -lt 3 ] && ([ -z "$TGZ_URL" ] || [ "$TGZ_URL" = "null" ]); then
        # Try to see what assets are available
        ASSET_COUNT=$(echo "$RELEASES_JSON" | jq -r ".[$i].assets | length" 2>/dev/null || echo "0")
        if [ "$ASSET_COUNT" -gt 0 ]; then
            ASSET_NAMES=$(echo "$RELEASES_JSON" | jq -r ".[$i].assets[] | .name" 2>/dev/null | head -3 | tr '\n' ',' | sed 's/,$//' || echo "")
            if [ -n "$ASSET_NAMES" ]; then
                info "Release $TAG_NAME: No .tgz found. Available assets: $ASSET_NAMES"
            fi
        fi
    fi
    
    # Extract version number from tag (e.g., v5.14 -> 5.14)
    VERSION=$(echo "$TAG_NAME" | sed 's/^v//')
    
    # Determine if it's a test release - check the name/tag
    if [ "$PRERELEASE" = "true" ] || echo "$NAME" | grep -qi "test"; then
        if [ -n "$TGZ_URL" ] && [ "$TGZ_URL" != "null" ]; then
            TEST_RELEASES+=("$VERSION|$TAG_NAME|$NAME|$TGZ_URL")
        else
            # Add to list even without .tgz file, mark it
            TEST_RELEASES+=("$VERSION|$TAG_NAME|$NAME|NO_TGZ")
        fi
    else
        if [ -n "$TGZ_URL" ] && [ "$TGZ_URL" != "null" ]; then
            PRODUCTION_RELEASES+=("$VERSION|$TAG_NAME|$NAME|$TGZ_URL")
        else
            # Add to list even without .tgz file, mark it
            PRODUCTION_RELEASES+=("$VERSION|$TAG_NAME|$NAME|NO_TGZ")
        fi
    fi
done

# Build ALL_RELEASES array in display order: production first, then test
ALL_RELEASES=("${PRODUCTION_RELEASES[@]}" "${TEST_RELEASES[@]}")

if [ ${#ALL_RELEASES[@]} -eq 0 ]; then
    error "No JMRI releases found after processing $RELEASE_COUNT releases from GitHub"
fi

info "Found ${#ALL_RELEASES[@]} releases (${#PRODUCTION_RELEASES[@]} production, ${#TEST_RELEASES[@]} test)"

# Handle --latest flag or show menu
if [ "$INSTALL_LATEST" = true ]; then
    # Automatically select the latest production release
    if [ ${#PRODUCTION_RELEASES[@]} -eq 0 ]; then
        error "No production releases found. Cannot install latest release."
    fi
    
    # Get the first production release (which is the latest)
    IFS='|' read -r SELECTED_VERSION SELECTED_TAG SELECTED_NAME SELECTED_URL <<< "${PRODUCTION_RELEASES[0]}"
    
    if [ "$SELECTED_URL" = "NO_TGZ" ]; then
        error "Latest production release does not have a .tgz file available for download."
    fi
    
    info "Installing latest production release: $SELECTED_NAME ($SELECTED_TAG)"
else
    # Display menu
    echo ""
    echo "Available JMRI Releases:"
    echo "========================"
    echo ""
    echo "PRODUCTION RELEASES:"
    if [ ${#PRODUCTION_RELEASES[@]} -eq 0 ]; then
        echo "  (none found)"
    else
        for i in "${!PRODUCTION_RELEASES[@]}"; do
            IFS='|' read -r VERSION TAG NAME URL <<< "${PRODUCTION_RELEASES[$i]}"
            if [ "$URL" = "NO_TGZ" ]; then
                echo "  $((i+1)). $NAME ($TAG) [No .tgz file]"
            else
                echo "  $((i+1)). $NAME ($TAG)"
            fi
        done
    fi

    echo ""
    echo "TEST RELEASES:"
    if [ ${#TEST_RELEASES[@]} -eq 0 ]; then
        echo "  (none found)"
    else
        START_NUM=$((${#PRODUCTION_RELEASES[@]}+1))
        for i in "${!TEST_RELEASES[@]}"; do
            IFS='|' read -r VERSION TAG NAME URL <<< "${TEST_RELEASES[$i]}"
            if [ "$URL" = "NO_TGZ" ]; then
                echo "  $((START_NUM+i)). $NAME ($TAG) [TEST - No .tgz file]"
            else
                echo "  $((START_NUM+i)). $NAME ($TAG) [TEST]"
            fi
        done
    fi

    echo ""
    read -p "Select release number (1-${#ALL_RELEASES[@]}): " SELECTION

    # Validate selection
    if ! [[ "$SELECTION" =~ ^[0-9]+$ ]] || [ "$SELECTION" -lt 1 ] || [ "$SELECTION" -gt ${#ALL_RELEASES[@]} ]; then
        error "Invalid selection"
    fi

    # Get selected release info
    SELECTED_INDEX=$((SELECTION-1))
    IFS='|' read -r SELECTED_VERSION SELECTED_TAG SELECTED_NAME SELECTED_URL <<< "${ALL_RELEASES[$SELECTED_INDEX]}"
fi

if [ "$SELECTED_URL" = "NO_TGZ" ]; then
    error "Selected release does not have a .tgz file available for download."
fi

info "Selected: $SELECTED_NAME ($SELECTED_TAG)"
info "Download URL: $SELECTED_URL"

# Extract directory name from URL (e.g., JMRI.5.14+Rdea51dcccf)
# Note: The actual directory name will be determined after extraction
# since the URL may contain encoded characters (%2B for +)
TGZ_FILENAME=$(basename "$SELECTED_URL" .tgz)
# We'll find the actual directory after extraction
INSTALL_DIR=""

# Check if already installed (look for any JMRI directory matching this version)
POTENTIAL_DIR=$(find "$JMRI_BASE_DIR" -maxdepth 1 -type d -name "JMRI.${SELECTED_VERSION}*" | head -1)
if [ -n "$POTENTIAL_DIR" ] && [ -d "$POTENTIAL_DIR" ]; then
    INSTALL_DIR="$POTENTIAL_DIR"
    if [ "$INSTALL_LATEST" = true ]; then
        # When using --latest, skip reinstall prompt and keep existing if same version
        info "JMRI $SELECTED_VERSION is already installed at $INSTALL_DIR"
        INSTALL_DIR_EXISTS=true
    else
        warn "JMRI $SELECTED_VERSION is already installed at $INSTALL_DIR"
        read -p "Reinstall? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            info "Keeping existing installation"
            INSTALL_DIR_EXISTS=true
        else
            info "Removing existing installation..."
            rm -rf "$INSTALL_DIR"
            INSTALL_DIR_EXISTS=false
            INSTALL_DIR=""
        fi
    fi
else
    INSTALL_DIR_EXISTS=false
fi

if [ "$INSTALL_DIR_EXISTS" = false ]; then
    # Download the .tgz file
    # Use /root for temp files instead of /tmp to avoid space issues on older Raspberry Pi's
    # /tmp might be on a small partition, but /root is typically on the main filesystem
    TEMP_BASE_DIR="/root/.jmri-install-tmp"
    mkdir -p "$TEMP_BASE_DIR"
    TEMP_DIR=$(mktemp -d -p "$TEMP_BASE_DIR")
    TEMP_TGZ="${TEMP_DIR}/${TGZ_FILENAME}.tgz"
    
    info "Downloading JMRI ${SELECTED_VERSION}..."
    curl -L -o "$TEMP_TGZ" "$SELECTED_URL" || error "Failed to download JMRI"
    
    # Verify download
    if [ ! -f "$TEMP_TGZ" ] || [ ! -s "$TEMP_TGZ" ]; then
        error "Downloaded file is empty or missing"
    fi
    
    info "Extracting JMRI..."
    # Extract to a temporary location first
    TEMP_EXTRACT_DIR=$(mktemp -d -p "$TEMP_BASE_DIR")
    tar -xzf "$TEMP_TGZ" -C "$TEMP_EXTRACT_DIR" || error "Failed to extract JMRI"
    
    # The tar file contains a top-level "JMRI" directory
    # We need to rename it to the versioned name
    EXTRACTED_JMRI_DIR="$TEMP_EXTRACT_DIR/JMRI"
    if [ ! -d "$EXTRACTED_JMRI_DIR" ]; then
        error "Extraction failed - JMRI directory not found in archive"
    fi
    
    # Determine the versioned directory name from the release tag/name
    # Use the tag name to create a unique directory name
    VERSIONED_DIR_NAME="JMRI.${SELECTED_TAG}"
    INSTALL_DIR="${JMRI_BASE_DIR}/${VERSIONED_DIR_NAME}"
    
    # Move the extracted directory to the versioned name
    mv "$EXTRACTED_JMRI_DIR" "$INSTALL_DIR" || error "Failed to move extracted directory to $INSTALL_DIR"
    
    # Clean up temp files and directories
    rm -rf "$TEMP_EXTRACT_DIR"
    rm -f "$TEMP_TGZ"
    rm -rf "$TEMP_DIR"
    # Clean up base temp directory if it's empty (may fail if not empty, which is fine)
    rmdir "$TEMP_BASE_DIR" 2>/dev/null || true
    
    if [ ! -d "$INSTALL_DIR" ]; then
        error "Installation failed - directory $INSTALL_DIR not found after move"
    fi
    
    if [ ! -f "$INSTALL_DIR/jmri.jar" ]; then
        error "Extraction incomplete - jmri.jar not found in $INSTALL_DIR"
    fi
    
    info "JMRI extracted and installed to: $INSTALL_DIR"
fi

# Update symlink
if [ -L "$JMRI_CURRENT_LINK" ]; then
    OLD_TARGET=$(readlink "$JMRI_CURRENT_LINK")
    info "Updating symlink from $OLD_TARGET to $INSTALL_DIR"
    rm "$JMRI_CURRENT_LINK"
elif [ -d "$JMRI_CURRENT_LINK" ]; then
    warn "Removing existing directory at $JMRI_CURRENT_LINK"
    rm -rf "$JMRI_CURRENT_LINK"
fi

ln -s "$INSTALL_DIR" "$JMRI_CURRENT_LINK"
info "Created symlink: $JMRI_CURRENT_LINK -> $INSTALL_DIR"

# Set permissions
chown -R root:root "$INSTALL_DIR"
chmod -R 755 "$INSTALL_DIR"
chown -h root:root "$JMRI_CURRENT_LINK"

# Make sure dcc-io user can read JMRI
if id -u dcc-io >/dev/null 2>&1; then
    # Allow dcc-io user to read JMRI files
    chmod -R o+r "$INSTALL_DIR"
    info "Set permissions for dcc-io user"
fi

info "JMRI ${SELECTED_VERSION} installed successfully!"

# Check for old JMRI installations and offer to clean them up
CURRENT_DIR_NAME=$(basename "$INSTALL_DIR")
OLD_INSTALLS=$(find "$JMRI_BASE_DIR" -maxdepth 1 -type d -name "JMRI.*" ! -name "$CURRENT_DIR_NAME" 2>/dev/null | sort -r)
if [ -n "$OLD_INSTALLS" ]; then
    OLD_COUNT=$(echo "$OLD_INSTALLS" | wc -l)
    CURRENT_LINK_TARGET=""
    if [ -L "$JMRI_CURRENT_LINK" ]; then
        CURRENT_LINK_TARGET=$(readlink -f "$JMRI_CURRENT_LINK")
    fi
    
    echo ""
    warn "Found $OLD_COUNT other JMRI installation(s) (excluding the one just installed):"
    TOTAL_SIZE=0
    for old_dir in $OLD_INSTALLS; do
        if [ -d "$old_dir" ]; then
            DIR_SIZE=$(du -sh "$old_dir" 2>/dev/null | cut -f1)
            TOTAL_SIZE_BYTES=$(du -sb "$old_dir" 2>/dev/null | cut -f1)
            TOTAL_SIZE=$((TOTAL_SIZE + TOTAL_SIZE_BYTES))
            if [ "$old_dir" = "$CURRENT_LINK_TARGET" ]; then
                echo "  - $(basename "$old_dir") (${DIR_SIZE}) [currently active via symlink]"
            else
                echo "  - $(basename "$old_dir") (${DIR_SIZE})"
            fi
        fi
    done
    
    TOTAL_SIZE_MB=$((TOTAL_SIZE / 1024 / 1024))
    echo ""
    info "Total disk space used by old installations: ~${TOTAL_SIZE_MB}MB"
    echo ""
    if [ "$INSTALL_LATEST" = true ]; then
        # Skip cleanup prompt when using --latest
        info "Skipping cleanup of old installations (use jmri-install manually to clean up)"
    else
        read -p "Remove old JMRI installations to free up disk space? [y/N] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
        FREED_SPACE=0
        for old_dir in $OLD_INSTALLS; do
            if [ -d "$old_dir" ]; then
                # Don't remove if it's the currently active installation
                if [ "$old_dir" = "$CURRENT_LINK_TARGET" ]; then
                    warn "Skipping $(basename "$old_dir") - it's the currently active installation"
                else
                    OLD_SIZE=$(du -sb "$old_dir" 2>/dev/null | cut -f1)
                    info "Removing $(basename "$old_dir")..."
                    rm -rf "$old_dir"
                    FREED_SPACE=$((FREED_SPACE + OLD_SIZE))
                fi
            fi
        done
            FREED_MB=$((FREED_SPACE / 1024 / 1024))
            info "Cleanup complete! Freed ~${FREED_MB}MB of disk space."
        else
            info "Old installations kept. You can remove them manually later if needed."
        fi
    fi
fi

# Check if dcc-io-daemon service exists and is running
if systemctl list-unit-files | grep -q dcc-io-daemon.service; then
    if systemctl is-active dcc-io-daemon >/dev/null 2>&1; then
        if [ "$INSTALL_LATEST" = true ]; then
            # Automatically restart when using --latest
            info "Restarting dcc-io-daemon service to use new JMRI..."
            systemctl restart dcc-io-daemon || warn "Failed to restart service"
        else
            echo ""
            read -p "Restart dcc-io-daemon service to use new JMRI? [Y/n] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Nn]$ ]]; then
                info "Restarting dcc-io-daemon service..."
                systemctl restart dcc-io-daemon || warn "Failed to restart service"
            fi
        fi
    else
        info "dcc-io-daemon service is not running. Start it with: sudo systemctl start dcc-io-daemon"
    fi
fi

echo ""
info "Installation complete!"
info "JMRI is available at: $JMRI_CURRENT_LINK"

